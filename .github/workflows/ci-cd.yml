name: CI/CD Pipeline

on:
  push:
    branches: [ "**" ]  # Trigger on all branches
  pull_request:
    branches: [ main ]   # Only on PRs to main
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  SOLUTION_FILE: 'Fiszki.sln'
  ARTIFACT_NAME: 'fiszki-release-build'
  PUBLISH_DIR: './publish'

jobs:
  build:
    name: üî® Build
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: ‚öôÔ∏è Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: üîÑ Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
    
    - name: üî® Build (Release)
      run: dotnet build ${{ env.SOLUTION_FILE }} --configuration Release --no-restore
    
    - name: üì¶ Publish artifacts (main branch only)
      if: github.ref == 'refs/heads/main'
      run: dotnet publish ${{ env.SOLUTION_FILE }} --configuration Release --no-build --output ${{ env.PUBLISH_DIR }}
    
    - name: üóÇÔ∏è Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          **/bin/Release/**
          **/obj/**
        retention-days: 1
    
    - name: üóÇÔ∏è Upload publish artifacts (main branch only)
      if: github.ref == 'refs/heads/main'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: ${{ env.PUBLISH_DIR }}/
        retention-days: 7

  unit-tests:
    name: üß™ Unit Tests
    runs-on: ubuntu-latest
    needs: build
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: ‚öôÔ∏è Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: üì• Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
    
    - name: üîÑ Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
    
    - name: üß™ Run unit tests
      run: |
        dotnet test Fiszki.Tests/Fiszki.Tests.csproj \
          --configuration Release \
          --no-build \
          --verbosity normal \
          --logger trx \
          --results-directory ./test-results \
          --collect:"XPlat Code Coverage"
    
    - name: üìä Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: unit-test-results
        path: ./test-results/
        retention-days: 7

  functional-tests:
    name: üé≠ Functional Tests (E2E)
    runs-on: windows-latest  # Changed from ubuntu-latest to windows-latest
    needs: [build, unit-tests]
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: ‚öôÔ∏è Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: üì• Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: build-artifacts
    
    - name: üîÑ Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
    
    - name: üî® Build for tests
      run: dotnet build ${{ env.SOLUTION_FILE }} --configuration Debug --no-restore
    
    - name: üé≠ Install Playwright dependencies
      run: |
        cd Fiszki.FunctionalTests
        dotnet build
        # Use PowerShell for Windows - install Playwright browsers
        pwsh ./bin/Debug/net8.0/playwright.ps1 install chromium --with-deps
      
    - name: üöÄ Start application in test mode (background)
      run: |
        Write-Host "Starting application in test mode..."
        $env:ASPNETCORE_ENVIRONMENT = "Test"
        $env:ASPNETCORE_URLS = "http://localhost:5000"
        $env:TestMode = "true"
        $env:OpenRouter__ApiKey = $env:OPENROUTER__APIKEY
        
        # Start the application in the background using PowerShell
        $process = Start-Process -FilePath "dotnet" -ArgumentList "run", "--project", "Fiszki.csproj", "--environment", "Test", "--urls", "http://localhost:5000" -RedirectStandardOutput "app.log" -RedirectStandardError "app.log" -PassThru -WindowStyle Hidden
        $process.Id | Out-File -FilePath "app.pid"
        Write-Host "Application started with PID: $($process.Id)"
        
        # Wait for application to start with Windows-compatible approach
        Write-Host "Waiting for application to start..."
        $timeout = 120  # 2 minutes timeout
        $elapsed = 0
        do {
            try {
                $response = Invoke-WebRequest -Uri "http://localhost:5000" -TimeoutSec 2 -ErrorAction SilentlyContinue
                if ($response.StatusCode -eq 200) {
                    Write-Host "Application is ready!"
                    break
                }
            } catch {
                # Continue waiting
            }
            Start-Sleep -Seconds 2
            $elapsed += 2
            Write-Host "Attempt $($elapsed/2): Application not ready yet..."
        } while ($elapsed -lt $timeout)
        
        # Final verification
        try {
            $response = Invoke-WebRequest -Uri "http://localhost:5000" -TimeoutSec 5
            Write-Host "Application is running and healthy"
        } catch {
            Write-Host "Application failed to start properly"
            if (Test-Path "app.log") {
                Write-Host "Application logs:"
                Get-Content "app.log"
            }
            exit 1
        }
      shell: pwsh
      env:
        ASPNETCORE_ENVIRONMENT: Test
        TestMode: true
        ASPNETCORE_URLS: http://localhost:5000
    
    - name: üß™ Run functional tests
      run: |
        cd Fiszki.FunctionalTests
        Write-Host "=== Starting functional tests ==="
        Write-Host "Environment: $env:ASPNETCORE_ENVIRONMENT"
        Write-Host "Base URL: $env:FISZKI_BASE_URL"
        Write-Host "Headless mode: $env:PW_HEADLESS"
        
        # Test if the application is responsive before running tests
        Write-Host "=== Testing application health ==="
        try {
            $response = Invoke-WebRequest -Uri "$env:FISZKI_BASE_URL/health" -TimeoutSec 5
            Write-Host "Health endpoint is accessible - Status: $($response.StatusCode)"
        } catch {
            Write-Host "Health endpoint not available: $_"
        }
        
        try {
            $response = Invoke-WebRequest -Uri "$env:FISZKI_BASE_URL/" -TimeoutSec 5
            Write-Host "Home page is accessible - Status: $($response.StatusCode)"
        } catch {
            Write-Host "Home page not accessible: $_"
        }
        
        try {
            $response = Invoke-WebRequest -Uri "$env:FISZKI_BASE_URL/login" -TimeoutSec 5
            Write-Host "Login page is accessible - Status: $($response.StatusCode)"
        } catch {
            Write-Host "Login page not accessible: $_"
        }
        
        # Run the tests with verbose output
        dotnet test --no-build --verbosity normal --logger "trx;LogFileName=functional-test-results.trx" --logger "console;verbosity=detailed"
      shell: pwsh
      env:
        ASPNETCORE_ENVIRONMENT: Test
        FISZKI_BASE_URL: http://localhost:5000
        PW_HEADLESS: true
    
    - name: üìã Show application logs (if tests fail)
      if: failure()
      run: |
        Write-Host "=== Application Logs ==="
        if (Test-Path "app.log") {
            Get-Content "app.log"
        } else {
            Write-Host "No application logs found"
        }
      shell: pwsh
    
    - name: üõë Stop application
      if: always()
      run: |
        if (Test-Path "app.pid") {
            $appPid = Get-Content "app.pid"
            if ($appPid) {
                Write-Host "Stopping application with PID: $appPid"
                try {
                    Stop-Process -Id $appPid -Force -ErrorAction SilentlyContinue
                    Write-Host "Application stopped successfully"
                } catch {
                    Write-Host "Could not stop application: $_"
                }
            }
            Remove-Item "app.pid" -ErrorAction SilentlyContinue
        }
      shell: pwsh

  required-status-check:
    name: üõ°Ô∏è Required Status Check
    runs-on: ubuntu-latest
    needs: [build, unit-tests, functional-tests]
    if: always() && (github.event_name == 'push' && github.ref == 'refs/heads/main')
    steps:
      - name: üîç Verify all jobs passed
        run: |
          echo "Checking status of all required jobs..."
          echo "Build status: ${{ needs.build.result }}"
          echo "Unit Tests status: ${{ needs.unit-tests.result }}"
          echo "Functional Tests status: ${{ needs.functional-tests.result }}"
          if [[ "${{ needs.build.result }}" != "success" ]]; then
            echo "‚ùå Build job failed or was cancelled"; exit 1; fi
          if [[ "${{ needs.unit-tests.result }}" != "success" ]]; then
            echo "‚ùå Unit Tests job failed or was cancelled"; exit 1; fi
          if [[ "${{ needs.functional-tests.result }}" == "skipped" ]]; then
            echo "‚ö†Ô∏è Functional tests were skipped (no PR to main) - deploying based on build and unit tests only"
          elif [[ "${{ needs.functional-tests.result }}" != "success" ]]; then
            echo "‚ùå Functional Tests job failed or was cancelled"; exit 1; fi
          echo "‚úÖ All required jobs passed - safe to deploy to Azure"

  deploy:
    name: üöÄ Deploy to Azure (main)
    runs-on: ubuntu-latest
    needs: [required-status-check]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.required-status-check.result == 'success'
    environment:
      name: Production
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    steps:
      - name: üì• Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}
          path: ${{ env.PUBLISH_DIR }}

      - name: üöÄ Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v3
        with:
          app-name: 'Fiszki'
          slot-name: 'Production'
          package: ${{ env.PUBLISH_DIR }}
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_93FA90C48A7B43BE9A3E282FD84CA1DA }}
